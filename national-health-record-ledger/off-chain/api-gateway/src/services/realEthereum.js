const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');

// Load Contract Artifact (ABI)
// In a real setup, this JSON is generated by Hardhat/Truffle
// For this script, we assume a simple ABI based on MedicalAnchor.sol
const CONTRACT_ABI = [
  "function anchorHash(string memory _metaId, string memory _hashString) public",
  "function verifyIntegrity(string memory _metaId, string memory _candidateHashString) public view returns (bool)",
  "event ProofAnchored(string indexed metaId, bytes32 indexed dataHash, address indexed hospital, uint256 timestamp)"
];

let provider;
let wallet;
let contract;

async function init() {
    if (contract) return;

    const rpcUrl = process.env.ETH_RPC_URL || 'http://localhost:8545';
    const privateKey = process.env.ETH_PRIVATE_KEY; // Must be set (e.g., from Ganache)
    const contractAddress = process.env.ETH_CONTRACT_ADDRESS;

    if (!privateKey || !contractAddress) {
        throw new Error("ETH_PRIVATE_KEY and ETH_CONTRACT_ADDRESS must be set in .env");
    }

    provider = new ethers.JsonRpcProvider(rpcUrl);
    wallet = new ethers.Wallet(privateKey, provider);
    contract = new ethers.Contract(contractAddress, CONTRACT_ABI, wallet);

    console.log(`[ETHEREUM] Connected to ${rpcUrl}`);
}

async function anchorHash(recordId, dataHash, senderId) {
    await init();

    console.log(`[ETHEREUM] Anchoring Hash for Record: ${recordId}`);
    try {
        // Send Transaction
        const tx = await contract.anchorHash(recordId, dataHash);
        console.log(`[ETHEREUM] Tx Sent: ${tx.hash}. Waiting for confirmation...`);

        const receipt = await tx.wait();
        console.log(`[ETHEREUM] Tx Mined in Block: ${receipt.blockNumber}`);

        return tx.hash;
    } catch (error) {
        console.error(`[ETHEREUM] Error: ${error.message}`);
        throw error;
    }
}

async function verifyIntegrity(recordId, hashString) {
    await init();
    console.log(`[ETHEREUM] Verifying Integrity for Record: ${recordId}`);
    try {
        const isValid = await contract.verifyIntegrity(recordId, hashString);
        return isValid;
    } catch (error) {
        console.error(`[ETHEREUM] Verification Error: ${error.message}`);
        // If proof doesn't exist, it might throw or return false depending on impl.
        // The contract view returns bool, but if metaId key is missing, defaults might apply.
        return false;
    }
}

module.exports = { anchorHash, verifyIntegrity };
